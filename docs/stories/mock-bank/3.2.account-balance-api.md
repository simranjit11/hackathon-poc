# Story 3.2: Account Balance API Endpoint

**Status:** Ready for Development  
**Epic:** Epic 2 - Account and Balance Read Operations  
**Related Architecture:** [Mock Bank APIs Architecture](../../mock-bank/architecture.md)  
**Dependencies:** Story 3.0 (Database Schema), Story 3.1 (Account Details API)

---

## Story

**As a** banking customer  
**I want to** retrieve my account balance(s)  
**So that** I can check my current balance for specific account types or all accounts

---

## Acceptance Criteria

1. **API Endpoint**: `GET /api/banking/accounts/balance` endpoint implemented
   - Requires JWT authentication
   - Optional query parameter: `accountType` (filter by "checking", "savings", "credit_card")
   - Returns balance(s) for filtered accounts or all accounts if no filter

2. **Response Format**: Returns array of balance objects with:
   - `accountId`: Account UUID
   - `accountNumber`: Account number
   - `accountType`: Account type
   - `balance`: Current balance (Decimal)
   - `creditLimit`: Credit limit (for credit cards, null otherwise)
   - `availableBalance`: Available balance (balance for checking/savings, creditLimit - balance for credit cards)
   - `currency`: Currency code

3. **Filtering**: 
   - If `accountType` query param provided, filter by account type
   - If no `accountType` provided, return all accounts
   - Filter validation: accountType must be one of: "checking", "savings", "credit_card"

4. **Security**: 
   - Only returns balances for accounts belonging to authenticated user
   - Uses existing authentication pattern

5. **Error Handling**: 
   - Returns 400 for invalid accountType parameter
   - Returns 401 for authentication errors
   - Returns 500 for database errors

6. **Performance**: Response time < 200ms

---

## Tasks / Subtasks

- [ ] **Task 1: Create API Route**
  - [ ] Create `app/api/banking/accounts/balance/route.ts`
  - [ ] Implement GET handler with authentication
  - [ ] Implement query parameter parsing and validation

- [ ] **Task 2: Business Logic**
  - [ ] Query accounts filtered by userId and optional accountType
  - [ ] Calculate availableBalance (different logic for credit cards)
  - [ ] Format response with balance information

- [ ] **Task 3: Validation**
  - [ ] Validate accountType parameter if provided
  - [ ] Return 400 for invalid accountType values

- [ ] **Task 4: Testing**
  - [ ] Test with no filter (all accounts)
  - [ ] Test with accountType filter
  - [ ] Test with invalid accountType
  - [ ] Test authentication

---

## Dev Notes

### Architecture Alignment
- **Pattern**: Follows existing API route patterns
- **Location**: `app/api/banking/accounts/balance/route.ts`
- **Query Parameters**: Use Next.js `request.nextUrl.searchParams`

### Available Balance Calculation
- **Checking/Savings**: `availableBalance = balance`
- **Credit Card**: `availableBalance = creditLimit - balance` (available credit)

### Implementation Pattern
```typescript
export async function GET(request: NextRequest) {
  // Authentication...
  
  const accountType = request.nextUrl.searchParams.get('accountType');
  
  const where: any = { userId: user.user_id };
  if (accountType) {
    if (!['checking', 'savings', 'credit_card'].includes(accountType)) {
      return corsResponse({ error: 'Invalid accountType' }, 400);
    }
    where.accountType = accountType;
  }
  
  const accounts = await prisma.account.findMany({
    where,
    select: { /* fields */ }
  });
  
  // Calculate availableBalance and format response
}
```

---

## Definition of Done

- [ ] API endpoint implemented
- [ ] Query parameter filtering working
- [ ] Available balance calculated correctly
- [ ] Validation for accountType parameter
- [ ] Error handling implemented
- [ ] Performance meets requirements

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-XX | 1.0 | Initial story creation | John (PM) |


