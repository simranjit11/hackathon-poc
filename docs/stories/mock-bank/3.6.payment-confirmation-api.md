# Story 3.6: Payment Confirmation API Endpoint

**Status:** Ready for Development  
**Epic:** Epic 4 - Payment and Transfer Operations  
**Related Architecture:** [Mock Bank APIs Architecture](../../mock-bank/architecture.md)  
**Dependencies:** Story 3.0 (Database Schema), Story 3.5 (Payment Initiation API)

---

## Story

**As a** banking customer  
**I want to** confirm my payment with an OTP code  
**So that** my payment is completed and funds are transferred

---

## Acceptance Criteria

1. **API Endpoint**: `POST /api/banking/payments/confirm` endpoint implemented
   - Requires JWT authentication with `transact` permission
   - Accepts paymentSessionId and OTP code

2. **Request Body**:
   ```json
   {
     "paymentSessionId": "payment_uuid_timestamp",
     "otpCode": "123456"
   }
   ```

3. **Business Logic**:
   - Validates OTP from Redis using paymentSessionId
   - Retrieves pending transaction linked to paymentSessionId
   - Validates transaction belongs to authenticated user
   - Validates transaction status is "pending"
   - Validates transaction hasn't expired
   - Re-checks source account has sufficient balance (prevents race conditions)
   - Completes transaction:
     - **Internal Transfer**: Updates both source (debit) and destination (credit) account balances atomically
     - **External Transfer**: Updates only source account balance (debit)
   - Updates transaction:
     - Sets `status: "completed"`
     - Generates `referenceNumber`: `TXN-{YYYYMMDD}-{random}`
     - Sets `completedAt` timestamp
   - Removes OTP from Redis after successful confirmation

4. **Response Format**: Returns:
   ```json
   {
     "transaction": {
       "id": "uuid",
       "status": "completed",
       "amount": 100.00,
       "fromAccount": "CHK-12345-001",
       "toAccount": "martha.doe@upi",
       "referenceNumber": "TXN-202501XX-ABC123",
       "completedAt": "2025-01-XX...",
       "beneficiary": { /* if applicable */ }
     },
     "message": "Payment completed successfully"
   }
   ```

5. **Validation**:
   - OTP must be valid 6-digit numeric code
   - OTP must match stored OTP for paymentSessionId
   - OTP must not be expired (5-minute TTL)
   - Payment session must exist
   - Transaction must be in "pending" status
   - Transaction must not be expired (10-minute window)
   - Source account must still have sufficient balance

6. **Error Handling**:
   - Returns 400 for invalid OTP
   - Returns 400 for expired OTP
   - Returns 400 for insufficient balance (re-check)
   - Returns 404 if payment session not found
   - Returns 409 if transaction already completed
   - Returns 400 if transaction expired
   - Returns 401 for authentication errors

7. **Transaction Safety**: Uses Prisma transactions to ensure atomicity:
   - Balance updates and transaction status update happen atomically
   - All or nothing - if any step fails, rollback

---

## Tasks / Subtasks

- [ ] **Task 1: Create API Route**
  - [ ] Create `app/api/banking/payments/confirm/route.ts`
  - [ ] Implement POST handler with authentication
  - [ ] Implement OPTIONS handler for CORS

- [ ] **Task 2: OTP Validation**
  - [ ] Use existing `verifyOTP` from `@/lib/otp-store`
  - [ ] Validate OTP code format (6-digit numeric)
  - [ ] Handle OTP expiration

- [ ] **Task 3: Transaction Retrieval**
  - [ ] Query transaction by paymentSessionId
  - [ ] Validate transaction belongs to user
  - [ ] Validate transaction status is "pending"
  - [ ] Validate transaction hasn't expired

- [ ] **Task 4: Balance Re-check**
  - [ ] Re-query source account balance
  - [ ] Validate sufficient balance still available
  - [ ] Prevents race conditions

- [ ] **Task 5: Transaction Completion**
  - [ ] Determine if internal or external transfer
  - [ ] Use Prisma transaction for atomicity:
     - Update source account balance (debit)
     - Update destination account balance (credit) if internal
     - Update transaction status to "completed"
     - Generate reference number
     - Set completedAt timestamp
  - [ ] Remove OTP from Redis

- [ ] **Task 6: Reference Number Generation**
  - [ ] Format: `TXN-{YYYYMMDD}-{6 random alphanumeric}`
  - [ ] Ensure uniqueness

- [ ] **Task 7: Testing**
  - [ ] Test with valid OTP
  - [ ] Test with invalid OTP
  - [ ] Test with expired OTP
  - [ ] Test with expired transaction
  - [ ] Test internal transfer completion
  - [ ] Test external transfer completion
  - [ ] Test insufficient balance on confirmation
  - [ ] Test transaction atomicity
  - [ ] Test OTP removal after confirmation

---

## Dev Notes

### Architecture Alignment
- **Pattern**: Follows existing API route patterns
- **Location**: `app/api/banking/payments/confirm/route.ts`
- **OTP**: Uses existing `verifyOTP` from `@/lib/otp-store`
- **Database**: Uses Prisma transactions for atomicity

### Transaction Atomicity
```typescript
await prisma.$transaction(async (tx) => {
  // 1. Update source account balance
  await tx.account.update({
    where: { id: sourceAccountId },
    data: { balance: { decrement: amount } }
  });
  
  // 2. Update destination account (if internal)
  if (isInternal) {
    await tx.account.update({
      where: { id: destAccountId },
      data: { balance: { increment: amount } }
    });
  }
  
  // 3. Update transaction status
  await tx.transaction.update({
    where: { id: transactionId },
    data: {
      status: 'completed',
      referenceNumber: generateReferenceNumber(),
      completedAt: new Date()
    }
  });
});
```

### Reference Number Format
`TXN-{YYYYMMDD}-{6 random uppercase alphanumeric}`

Example: `TXN-20250115-A3B9C2`

---

## Definition of Done

- [ ] API endpoint implemented
- [ ] OTP validation working
- [ ] Transaction retrieval and validation working
- [ ] Balance updates working atomically
- [ ] Internal and external transfers handled correctly
- [ ] Reference number generation working
- [ ] Error handling implemented
- [ ] OTP cleanup after confirmation

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-XX | 1.0 | Initial story creation | John (PM) |


